
//System drivers
#include "xuartps.h"
#include "xparameters.h"
#include "xplatform_info.h"
#include "xuartps.h"
#include "xil_exception.h"

#ifdef XPAR_INTC_0_DEVICE_ID
#include "xintc.h"
#else
#include "xscugic.h"
#endif

//Header file for this driver
#include "uart.h"

//Defines for interrupts
/************************** Constant Definitions **************************/

/*
 * The following constants map to the XPAR parameters created in the
 * xparameters.h file. They are defined here such that a user can easily
 * change all the needed parameters in one place.
 */
#ifdef XPAR_INTC_0_DEVICE_ID
#define INTC		XIntc
#define UART_DEVICE_ID		XPAR_XUARTPS_0_DEVICE_ID
#define INTC_DEVICE_ID		XPAR_INTC_0_DEVICE_ID
#define UART_INT_IRQ_ID		XPAR_INTC_0_UARTPS_0_VEC_ID
#else
#define INTC		XScuGic
#define UART_DEVICE_ID		XPAR_XUARTPS_0_DEVICE_ID
#define INTC_DEVICE_ID		XPAR_SCUGIC_SINGLE_DEVICE_ID
#define UART_INT_IRQ_ID		XPAR_XUARTPS_1_INTR
#endif

XUartPs Uart_PS;		/* Instance of the UART Device */
INTC InterruptController;	/* Instance of the Interrupt Controller */

//Function prototypes
static int SetupInterruptSystem(INTC *IntcInstancePtr,
				XUartPs *UartInstancePtr,
				u16 UartIntrId);

void Handler(void *CallBackRef, u32 Event, unsigned int EventData);


//returns 0 on success
uint8_t uart_init_polled()
{
	int Status;
	XUartPs_Config *Config;


	/*
	 * Initialize the UART driver so that it's ready to use.
	 * Look up the configuration in the config table, then initialize it.
	 */
	Config = XUartPs_LookupConfig(UART_DEVICE_ID);
	if (NULL == Config) {
		return XST_FAILURE;
	}

	Status = XUartPs_CfgInitialize(&Uart_PS, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/* Check hardware build. */
	Status = XUartPs_SelfTest(&Uart_PS);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}


uint8_t uart_init_interrupt()
{

}

//Returns 0 on success
uint8_t uart_send_byte(uint8_t data_byte)
{
	//Wait until we're done sending
	while (XUartPs_IsSending(&Uart_PS));

	//Send one byte
	if(XUartPs_Send(&Uart_PS, &data_byte, 1) != 1)
	{
		return XST_FAILURE;
	}
	return XST_SUCCESS;
}

//Returns number of bytes written into buffer
uint32_t uart_receive_bytes(uint32_t num_bytes, uint8_t * buff)
{
	uint32_t bytes_got = 0;

	while (bytes_got < num_bytes) {
		bytes_got +=
			XUartPs_Recv(&Uart_PS, buff + bytes_got,
				      (num_bytes - bytes_got));
	}

	return bytes_got;
}
