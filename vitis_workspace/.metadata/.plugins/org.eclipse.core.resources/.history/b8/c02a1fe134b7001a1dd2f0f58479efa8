
#include "cmd_handler.h"
#include "uart.h"
#include "gpio.h"

//Command definitions for this code and the RTL module
#define CMD_PREAMBLE 0xAA
#define CMD_RST_CLK 0x00
#define CMD_SEND_PULSE 0x01
#define CMD_SET_PERIOD 0x02
#define CMD_PHASE_MEAS_ON 0x03
#define CMD_PHASE_MEAS_OFF 0x04

//Handler function states
#define STATE_WAIT_PREAMBLE 0
#define STATE_WAIT_CMD 1
#define STATE_WAIT_PAYLOAD 2
u8 cmd_state;
u8 curr_cmd;

//Initializes UART, GPIO and RFSOC
//Returns 0 on success
u8 cmd_init()
{
	cmd_state = 0;

	print("Initializing peripherals...\r\n");

	if(gpio_init())
	{
		print("Failed to initialize GPIO!\r\n");
		return 1;
	}
	else
	{
		print("Successfully initialized GPIO!\r\n");
	}

	if(uart_init_interrupt() != 0)
	{
		print("Failed to initialize UART!");
		return 1;
	}
	else
	{
		print("Successfully initialized UART!");
	}

	print("Finished initializing peripherals");
	//Clear the buffer once
	uart_clear_buffer();

}

//Main command handler function
void cmd_update_state()
{
	switch(cmd_state)
	{

	case STATE_WAIT_PREAMBLE:

		//Check to see if there is a preamble byte waiting
		if(uart_get_buffer_size())
		{
			//Check to see if the byte is correct
			u8 p_b = uart_get_buffer_byte();
			if(p_b == CMD_PREAMBLE)
			{
				//Preamble byte is correct, we can move on to the next state
				cmd_state = STATE_WAIT_CMD;
			}
			else
			{
				xil_printf("Got bad preamble byte: 0x%x", p_b);
			}
		}
		break;


	case STATE_WAIT_CMD:

		//Check to see if there is a command byte waiting
		if(uart_get_buffer_size())
		{
			//Decode the command
			curr_cmd = uart_get_buffer_byte();
			switch(curr_cmd)
			{
			case CMD_RST_CLK:
				//Send the clock reset command
				gpio_send_commnd( ((u32)CMD_RST_CLK) << 24);
				cmd_state = STATE_WAIT_PREAMBLE;
				break;

				//These two are handled in the same manner
			case CMD_SEND_PULSE:
			case CMD_SET_PERIOD:

				//Handle these in their own FMS state
				cmd_state = STATE_WAIT_PAYLOAD;
				break;

			case CMD_PHASE_MEAS_ON:
				//Send the set phase meas command
				gpio_send_commnd( ((u32)CMD_PHASE_MEAS_ON) << 24);
				cmd_state = STATE_WAIT_PREAMBLE;
				break;

			case CMD_PHASE_MEAS_OFF:
				//Send the set phase meas command
				gpio_send_commnd( ((u32)CMD_PHASE_MEAS_OFF) << 24);
				cmd_state = STATE_WAIT_PREAMBLE;
				break;

			}
		}
		break;

	case STATE_WAIT_PAYLOAD:

		//Check if we have 3 payload bytes yet
		if(uart_get_buffer_size >= 3)
		{
			u32 b0, b1, b2;
			b0 = uart_get_buffer_byte();
			b1 = uart_get_buffer_byte();
			b2 = uart_get_buffer_byte();

			u32 cmd_f = (((u32)curr_cmd) << 24) | (b0 << 16) | (b1 << 8) | b2;

			cmd_state = STATE_WAIT_PREAMBLE;

		}
		break;
	}
}





